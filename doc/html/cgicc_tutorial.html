<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
   "http://www.w3.org/TR/REC-html40/loose.dtd">

<html lang="en" dir="LTR">

<head>
  <!-- $Id: header.html,v 1.2 2002/01/09 17:13:12 sbooth Exp $ -->
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <title>A Tutorial Example</title>
  <link rev="made" href="mailto:sbooth@gnu.org" />
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="cgicc.css" rel="stylesheet" type="text/css" />
</head>

<body>
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><a name="cgicc_tutorial"><h2>A Tutorial Example</h2></a>
 <a name="tut_intro"><h3>Introduction</h3></a>

<p>
It is easiest to understand how the GNU cgicc library might be used by first looking at an example. Suppose you want an HTML form on your web site asking a user to enter their name, age, and sex, perhaps as part of a user-registration procedure, and you wish to write a CGI script using cgicc to process the form in some meaningful way.
<p>
You would begin by creating an HTML form containing
<p>
<div class="fragment"><pre>
&lt;form method="post" action="http://change_this_path/cgi-bin/foo.cgi"&gt;
Your name : &lt;input type="text" name="name" /&gt;&lt;br /&gt;
Your age : &lt;input type="text" name="age" /&gt;&lt;br /&gt;
Your sex : &lt;input type="radio" name="sex" value="male"checked="checked" /&gt;Male
&lt;input type="radio" name="sex" value="female" /&gt;Female &lt;br /&gt;
&lt;/form&gt;
</pre></div>
<p>
Then, on to the CGI application. Applications written using cgicc, like all other applications, begin with a <code>main</code> function:
<p>
<div class="fragment"><pre><font class="keywordtype">int</font> main(<font class="keywordtype">int</font> argc, <font class="keywordtype">char</font> **argv)
{
   <font class="comment">// CGI processing goes here</font>
}
</pre></div>
<p>
<a name="tut_init"><h3>Initialization</h3></a>

<p>
The three main classes of cgicc you will use to process the submitted data are <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code>, <code><a class="el" href="classcgicc_1_1CgiEnvironment.html">cgicc::CgiEnvironment</a></code>, and <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code>. These classes will be explained in detail later; for now, it is sufficient to know that:
<p>
<ul>
<li>The class <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code> is used for retrieving information on the submitted form elements.
<p>
<li>The class <code><a class="el" href="classcgicc_1_1CgiEnvironment.html">cgicc::CgiEnvironment</a></code> is used to retrieve information on environment variables passed from the HTTP server.
<p>
<li>The class <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> is used to extract various types of data from the submitted form elements. </ul>
All of cgicc's functionality is accessed through class <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code>. Thus, the first step in CGI processing is to instantiate an object of type <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code>:
<p>
<div class="fragment"><pre><a class="code" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a> cgi;
</pre></div>
<p>
or
<p>
<div class="fragment"><pre><font class="keyword">using</font> <font class="keyword">namespace </font>cgicc;
Cgicc cgi;
</pre></div>
<p>
Upon instantiation, the class <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code> parses all data passed to the CGI script by the HTTP server.
<p>
Since errors are handled using exceptions, you may wish to wrap your CGI code in a <code>try</code> block to better handle unexpected conditions:
<p>
<div class="fragment"><pre><font class="keywordflow">try</font> {
   <a class="code" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a> cgi;
}

<font class="keywordflow">catch</font>(exception&amp; e) {
   <font class="comment">// Caught a standard library exception</font>
}
</pre></div>
<p>
<a name="tut_forminfo"><h3>Extracting Form Information</h3></a>

<p>
Each element of data entered by the user is parsed into a <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code>. A <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> contains methods for accessing data as strings, integers, and doubles. In the form mentioned above, a user would enter their name, age, and sex. Regardless of the type of value, the data is accessed using <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> (Note: this is not entirely true. For uploaded files, the data is accessed via the class <code><a class="el" href="classcgicc_1_1FormFile.html">cgicc::FormFile</a>)</code>. You obtain <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> objects via <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a>'s</code> <code>getElement</code> methods, all of which return typedefs of C++ standard template library (STL) iterators:
<p>
<div class="fragment"><pre>cgicc::form_iterator name = cgi.<a class="code" href="classcgicc_1_1Cgicc.html#z2_3">getElement</a>(<font class="stringliteral">"name"</font>);
</pre></div>
<p>
If the item is not found, the iterator will refer to an invalid element, and should not be dereferenced using <code>operator*</code> or <code>operator-&gt;</code>. <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code> provides methods for determining whether an iterator refers to a valid element:
<p>
<div class="fragment"><pre><font class="keywordflow">if</font>(name != cgi.<a class="code" href="classcgicc_1_1Cgicc.html#z2_10">getElements</a>().end()) {
   <font class="comment">// iterator refers to a valid element</font>
}
</pre></div>
<p>
<a name="tut_output"><h3>Output of Form Data</h3></a>

<p>
Once you have a valid element, you will more than likely want to do something with the data. The simplest thing to do is just echo it back to the user. You can extract a <code>string</code> from a <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> by calling the <code>getValue</code> method. Since <code>ostream</code> has an overload for writing <code>basic_string</code> objects, it is trivial to output objects of this type:
<p>
<div class="fragment"><pre>cout &lt;&lt; <font class="stringliteral">"Your name is "</font> &lt;&lt; name-&gt;getValue() &lt;&lt; endl;
</pre></div>
<p>
Since both <code>iterator</code> and <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> overload <code>operator*</code>, the code given above may also be written as:
<p>
<div class="fragment"><pre>cout &lt;&lt; <font class="stringliteral">"Your name is "</font> &lt;&lt; **name &lt;&lt; endl;
</pre></div>
<p>
The first <code>*</code> returns an object of type <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code>, and the second * returns an object of type <code>string</code>.
<p>
<a name="tut_response"><h3>The HTTP Response</h3></a>

<p>
A CGI response will generally consist of an HTML document. The HTTP protocol requires that a certain set of headers precede all documents, to inform the client of the size and type of data being received, among other things. In a normal CGI response, the HTTP server will take care of sending many of these headers for you. However, it is necessary for the CGI script to supply the type of content it is returning to the HTTP server and the client. This is done by emitting a <code>Content-Type</code> header. If you're interested, the full HTTP 1.1 specification may be found in RFC 2068 at <a href="http://www.w3.org/Protocols/rfc2068/rfc2068">http://www.w3.org/Protocols/rfc2068/rfc2068</a>
<p>
cgicc provides several classes for outputting HTTP headers, all of which begin with <code>HTTP</code>. A standard HTML 4.0 document need only output a single header:
<p>
<div class="fragment"><pre>cout &lt;&lt; HTTPHTMLHeader() &lt;&lt; endl;
</pre></div>
<p>
This will generate the output
<p>
<div class="fragment"><pre>
Content-Type: text/html\n\n
</pre></div>
<p>
<a name="tut_output"><h3>Output of Form Data</h3></a>

<p>
cgicc provides one class for every HTML tag defined in the HTML 4.0 standard in the header file "<code><a class="el" href="HTMLClasses_8h.html">cgicc/HTMLClasses.h</a></code>". These classes have the same name as the HTML tags. For example, in HTML, to indicate the start of a document you write <code>&lt;html&gt;</code> ; this can be accomplished using cgicc by writing
<p>
<div class="fragment"><pre>cout &lt;&lt; html() &lt;&lt; endl;
</pre></div>
<p>
The class <code>html</code> keeps state internally, so the code above will produce as output <code>&lt;html&gt;</code>; conversely, the code
<p>
<div class="fragment"><pre>cout &lt;&lt; html() &lt;&lt; <font class="stringliteral">"html text!"</font> &lt;&lt; html() &lt;&lt; endl;
</pre></div>
<p>
will produce as output <code>&lt;html&gt;html text!&lt;/html&gt;</code>.
<p>
All of cgicc's HTML output classes are subclasses of the abstract class <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code>. You can embed the text for the element directly in the constructor:
<p>
<div class="fragment"><pre>cout &lt;&lt; html(<font class="stringliteral">"html text!"</font>) &lt;&lt; endl;
</pre></div>
<p>
Furthermore, it is possible to embed one <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code> in another:
<p>
<div class="fragment"><pre>cout &lt;&lt; head(title(<font class="stringliteral">"Title"</font>)) &lt;&lt; endl;
</pre></div>
<p>
This produces as output  <div class="fragment"><pre>
&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;
</pre></div>
<p>
And, if you wish be more specific about the type of HTML 4.0 you are going to return (strict, transitional, or frameset), you can use the class <a class="el" href="classcgicc_1_1HTMLDoctype.html">cgicc::HTMLDoctype</a> before the cgicc::html tag:
<p>
<div class="fragment"><pre>cout &lt;&lt; HTMLDoctype(HTMLDoctype::eStrict) &lt;&lt; endl;
</pre></div>
<p>
which produces
<p>
<div class="fragment"><pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd"&gt;
</pre></div>
<p>
<a name="tut_complexoutput"><h3>More Complex HTML Output</h3></a>

<p>
In real HTML, most tags possess a set of attributes. For example, the HTML <code>&lt;img&gt;</code> tag requires certain attributes specifying the source image file, the image width, height, and so on. There are a bewildering number of possible attributes in HTML 4.0. For a definitive list, see the HTML 4.0 specification at <a href="http://www.w3.org/TR/REC-html40/">http://www.w3.org/TR/REC-html40/</a> A typical <code>&lt;img&gt;</code> tag might look like:
<p>
<div class="fragment"><pre>
&lt;img src="file.jpg" width="100" height="100" alt="description" /&gt;
</pre></div>
<p>
This tag has four attributes: <code>src</code>, <code>width</code>, <code>height</code>, and <code>alt</code>, with the values <code>file.jpg</code>, <code>100</code>, <code>100</code>, and <code>description</code>, respectively. Attributes in HTML tags are represented by the class <code><a class="el" href="classcgicc_1_1HTMLAttribute.html">cgicc::HTMLAttribute</a></code>, which essentially is a name/value pair. To build an <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code> containing <code><a class="el" href="classcgicc_1_1HTMLAttribute.html">cgicc::HTMLAttribute</a></code> objects, use the <code>set</code> method on <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code>. To generate the <code>&lt;img&gt;</code> tag given above:
<p>
<div class="fragment"><pre>cout &lt;&lt; img().set(<font class="stringliteral">"src"</font>, <font class="stringliteral">"file.jpg"</font>)
             .set(<font class="stringliteral">"width"</font>, <font class="stringliteral">"100"</font>).set(<font class="stringliteral">"height"</font>, <font class="stringliteral">"100"</font>)
             .set(<font class="stringliteral">"alt"</font>, <font class="stringliteral">"description"</font>) &lt;&lt; endl;
</pre></div>
<p>
In a similar way, multiple <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code> objects may be embedded at the same level inside another <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code>. To build an <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code> containing multiple embedded <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code> objects, use the <code>add</code> method on <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code>:
<p>
<div class="fragment"><pre>cout &lt;&lt; tr().add(td(<font class="stringliteral">"0"</font>)).add(td(<font class="stringliteral">"1"</font>)).add(td(<font class="stringliteral">"2"</font>)) &lt;&lt; endl;
</pre></div>
<p>
This produces as output <div class="fragment"><pre>
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
</pre></div>
<p>
<a name="tut_notesoutput"><h3>Notes on Output</h3></a>

<p>
All of cgicc's output is written to the C++ standard output stream, <code>cout</code>. It is not necessary to use cgicc's HTML output classes; they are provided as a convenience. If you prefer, you may output the HTML code directly to <code>cout</code>.
<p>
<a name="tut_example"><h3>The Complete Example</h3></a>

<p>
The code below is a complete CGI program that synthesizes all the sample code given in this chapter.
<p>
<div class="fragment"><pre><font class="preprocessor">#include &lt;iostream&gt;</font>
<font class="preprocessor">#include &lt;vector&gt;</font>
<font class="preprocessor">#include &lt;string&gt;</font>

<font class="preprocessor">#include "<a class="code" href="Cgicc_8h.html">cgicc/Cgicc.h</a>"</font>
<font class="preprocessor">#include "<a class="code" href="HTMLClasses_8h.html">cgicc/HTMLClasses.h</a>"</font>

<font class="keyword">using</font> <font class="keyword">namespace </font>std;
<font class="keyword">using</font> <font class="keyword">namespace </font>cgicc;

<font class="keywordtype">int</font> 
main(<font class="keywordtype">int</font> argc, 
     <font class="keywordtype">char</font> **argv)
{
   <font class="keywordflow">try</font> {
      Cgicc cgi;

      <font class="comment">// Send HTTP header</font>
      cout &lt;&lt; HTTPHTMLHeader() &lt;&lt; endl;

      <font class="comment">// Set up the HTML document</font>
      cout &lt;&lt; html() &lt;&lt; &lt;&lt; head(title(<font class="stringliteral">"Cgicc example"</font>)) &lt;&lt; endl;
      cout &lt;&lt; body() &lt;&lt; endl;

      <font class="comment">// Print out the submitted element</font>
      <a class="code" href="namespacecgicc.html#a0">form_iterator</a> name = cgi.<a class="code" href="classcgicc_1_1Cgicc.html#z2_3">getElement</a>(<font class="stringliteral">"name"</font>);
      <font class="keywordflow">if</font>(name != cgi.<a class="code" href="classcgicc_1_1Cgicc.html#z2_10">getElements</a>().end()) {
         cout &lt;&lt; <font class="stringliteral">"Your name: "</font> &lt;&lt; **name &lt;&lt; endl;
      }

      <font class="comment">// Close the HTML document</font>
      cout &lt;&lt; body() &lt;&lt; html();
   }
   <font class="keywordflow">catch</font>(exception&amp; e) {
      <font class="comment">// handle any errors - omitted for brevity</font>
   }
}
</pre></div>
<p>
<small>
[ Previous: <a href="lib_overview.html#lib_overview">Library Overview</a> |  Current: <a href="cgicc_tutorial.html#cgicc_tutorial">A Tutorial Example</a> |  Next: <a href="cgicc_demos.html#cgicc_demos">GNU cgicc Demos</a> ]</small>

<p>
<!-- $Id: footer.html,v 1.2 2002/01/09 17:13:12 sbooth Exp $ -->

<hr>

<address><small>
GNU cgicc - A C++ class library for writing CGI applications<br />
Copyright &copy; 1996, 1997, 1998, 1999, 2000, 2001, 2002 
<a href="mailto:sbooth@gnu.org">Stephen F. Booth</a><br />
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front Cover Texts, and with no Back-Cover
Texts.<br />
Documentation generated Wed Jan 9 12:31:26 2002 for cgicc by
<a HREF="http://www.doxygen.org/index.html">doxygen</a> 1.2.13.1
</small></address>

</body>

</html>

