<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
   "http://www.w3.org/TR/REC-html40/loose.dtd">

<html lang="en" dir="LTR">

<head>
  <!-- $Id: header.html,v 1.5 2004/06/12 01:58:25 sbooth Exp $ -->
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <title>A Tutorial Example</title>
  <link rev="made" href="mailto:bug-cgicc@gnu.org" />
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="cgicc-doc.css" rel="stylesheet" type="text/css" />
</head>

<body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="cgicc_tutorial">A Tutorial Example</a></h1>
<div class="header">Introduction</div>
<div class="subsection">
<p>
It is easiest to understand how the GNU cgicc library might be used by first looking at an example. Suppose you want an HTML form on your web site asking a user to enter their name, age, and sex, perhaps as part of a user-registration procedure, and you wish to write a CGI script using cgicc to process the form in some meaningful way.<p>
You would begin by creating an HTML form containing the HTML fragment<p>
<pre class="fragment"><div>
&lt;form method="post" action="http://change_this_path/cgi-bin/foo.cgi"&gt;
Your name : &lt;input type="text" name="name" /&gt;&lt;br /&gt;
Your age : &lt;input type="text" name="age" /&gt;&lt;br /&gt;
Your sex : &lt;input type="radio" name="sex" value="male"checked="checked" /&gt;Male
&lt;input type="radio" name="sex" value="female" /&gt;Female &lt;br /&gt;
&lt;/form&gt;
</div></pre><p>
Then, on to the CGI application. Applications written using cgicc, like all other applications, begin with a <code>main</code> function:<p>
<pre class="fragment"><div><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
   <span class="comment">// CGI processing goes here</span>
}
</div></pre><p>

</div>
<p>

<div class="header">Initialization</div>
<div class="subsection">
<p>
The three main classes of cgicc you will use to process the submitted data are <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code>, <code><a class="el" href="classcgicc_1_1CgiEnvironment.html">cgicc::CgiEnvironment</a></code>, and <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code>. These classes will be explained in detail later; for now, it is sufficient to know that:<p>
<ul>
<li>
The class <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code> is used for retrieving information on the submitted form elements.<p>
</li>
<li>
The class <code><a class="el" href="classcgicc_1_1CgiEnvironment.html">cgicc::CgiEnvironment</a></code> is used to retrieve information on environment variables passed from the HTTP server.<p>
</li>
<li>
The class <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> is used to extract various types of data from the submitted form elements. </li>
</ul>
<p>
All of cgicc's functionality is accessed through class <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code>. Thus, the first step in CGI processing is to instantiate an object of type <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code>:<p>
<pre class="fragment"><div><a class="code" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a> cgi;
</div></pre><p>
or<p>
<pre class="fragment"><div><span class="keyword">using</span> <span class="keyword">namespace </span>cgicc;
<a class="code" href="classcgicc_1_1Cgicc.html">Cgicc</a> cgi;
</div></pre><p>
Upon instantiation, the class <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code> parses all data passed to the CGI script by the HTTP server.<p>
Since errors are handled using exceptions, you may wish to wrap your CGI code in a <code>try</code> block to better handle unexpected conditions:<p>
<pre class="fragment"><div><span class="keywordflow">try</span> {
   <a class="code" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a> cgi;
}

<span class="keywordflow">catch</span>(exception&amp; e) {
   <span class="comment">// Caught a standard library exception</span>
}
</div></pre><p>

</div>
<p>

<div class="header">Extracting Form Information</div>
<div class="subsection">
<p>
Each element of data entered by the user is parsed into a <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code>. A <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> contains methods for accessing data as strings, integers, and doubles. In the form mentioned above, a user would enter their name, age, and sex. Regardless of the type of value, the data is accessed using <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> (this is not entirely true. For uploaded files, the data is accessed via the class <code><a class="el" href="classcgicc_1_1FormFile.html">cgicc::FormFile</a></code>). You obtain <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> objects via <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a>'s</code> <code>getElement</code> methods, all of which return typedefs of C++ standard template library (STL) iterators:<p>
<pre class="fragment"><div><a class="code" href="namespacecgicc.html#a0">cgicc::form_iterator</a> name = cgi.<a class="code" href="classcgicc_1_1Cgicc.html#z5_3">getElement</a>(<span class="stringliteral">"name"</span>);
</div></pre><p>
If the item is not found, the iterator will refer to an invalid element, and should not be dereferenced using <code>operator*</code> or <code>operator-&gt;</code>. <code><a class="el" href="classcgicc_1_1Cgicc.html">cgicc::Cgicc</a></code> provides methods for determining whether an iterator refers to a valid element:<p>
<pre class="fragment"><div><span class="keywordflow">if</span>(name != cgi.<a class="code" href="classcgicc_1_1Cgicc.html#z5_10">getElements</a>().end()) {
   <span class="comment">// iterator refers to a valid element</span>
}
</div></pre><p>

</div>
<p>

<div class="header">Output of Form Data</div>
<div class="subsection">
<p>
Once you have a valid element, you will more than likely want to do something with the data. The simplest thing to do is just echo it back to the user. You can extract a <code>basic_string</code> from a <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> by calling the <code>getValue</code> method. Since <code>ostream</code> has an overload for writing <code>basic_string</code> objects, it is trivial to output objects of this type:<p>
<pre class="fragment"><div>cout &lt;&lt; <span class="stringliteral">"Your name is "</span> &lt;&lt; name-&gt;getValue() &lt;&lt; endl;
</div></pre><p>
Since both <code>iterator</code> and <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code> overload <code>operator*</code>, the code given above may also be written as:<p>
<pre class="fragment"><div>cout &lt;&lt; <span class="stringliteral">"Your name is "</span> &lt;&lt; **name &lt;&lt; endl;
</div></pre><p>
The first <code>*</code> returns an object of type <code><a class="el" href="classcgicc_1_1FormEntry.html">cgicc::FormEntry</a></code>, and the second * returns an object of type <code>basic_string</code>.<p>

</div>
<p>

<div class="header">The HTTP Response</div>
<div class="subsection">
<p>
A CGI response will generally consist of an HTML document. The HTTP protocol requires that a certain set of headers precede all documents, to inform the client of the size and type of data being received, among other things. In a normal CGI response, the HTTP server will take care of sending many of these headers for you. However, it is necessary for the CGI script to supply the type of content it is returning to the HTTP server and the client. This is done by emitting a <code>Content-Type</code> header. If you're interested, the full HTTP 1.1 specification may be found in RFC 2068 at <a href="http://www.w3.org/Protocols/rfc2068/rfc2068">http://www.w3.org/Protocols/rfc2068/rfc2068</a><p>
cgicc provides several classes for outputting HTTP headers, all of which begin with <code>HTTP</code>. A standard HTML 4.0 document need only output a single header:<p>
<pre class="fragment"><div>cout &lt;&lt; <a class="code" href="classcgicc_1_1HTTPHTMLHeader.html">cgicc::HTTPHTMLHeader</a>() &lt;&lt; endl;
</div></pre><p>
This will generate the output<p>
<pre class="fragment"><div>
Content-Type: text/html\n\n
</div></pre><p>

</div>
<p>

<div class="header">Simple HTML Output</div>
<div class="subsection">
<p>
cgicc provides one class for every HTML tag defined in the HTML 4.0 standard in the header file <code>"cgicc/HTMLClasses.h"</code>. These classes have the same name as the HTML tags. For example, in HTML, to indicate the start of a document you write <code>&lt;html&gt;</code> ; this can be accomplished using cgicc by writing<p>
<pre class="fragment"><div>cout &lt;&lt; html() &lt;&lt; endl;
</div></pre><p>
The class <code>html</code> keeps state internally, so the code above will produce as output <code>&lt;html&gt;</code>; conversely, the code<p>
<pre class="fragment"><div>cout &lt;&lt; html() &lt;&lt; <span class="stringliteral">"html text!"</span> &lt;&lt; html() &lt;&lt; endl;
</div></pre><p>
will produce as output <code>&lt;html&gt;html text!&lt;/html&gt;</code>.<p>
All of cgicc's HTML output classes are subclasses of the abstract class <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code>. You can embed the text for the element directly in the constructor:<p>
<pre class="fragment"><div>cout &lt;&lt; html(<span class="stringliteral">"html text!"</span>) &lt;&lt; endl;
</div></pre><p>
Furthermore, it is possible to embed one <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code> in another:<p>
<pre class="fragment"><div>cout &lt;&lt; head(title(<span class="stringliteral">"Title"</span>)) &lt;&lt; endl;
</div></pre><p>
This produces as output <pre class="fragment"><div>
&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;
</div></pre><p>
And, if you wish be more specific about the type of HTML 4.0 you are going to return (strict, transitional, or frameset), you can use the class <a class="el" href="classcgicc_1_1HTMLDoctype.html">cgicc::HTMLDoctype</a> before the cgicc::html tag:<p>
<pre class="fragment"><div>cout &lt;&lt; <a class="code" href="classcgicc_1_1HTMLDoctype.html">HTMLDoctype</a>(HTMLDoctype::eStrict) &lt;&lt; endl;
</div></pre><p>
which produces<p>
<pre class="fragment"><div>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd"&gt;
</div></pre><p>

</div>
<p>

<div class="header">More Complex HTML Output</div>
<div class="subsection">
<p>
In real HTML, most tags possess a set of attributes. For example, the HTML <code>&lt;img&gt;</code> tag requires certain attributes specifying the source image file, the image width, height, and so on. There are a bewildering number of possible attributes in HTML 4.0. For a definitive list, see the HTML 4.0 specification at <a href="http://www.w3.org/TR/REC-html40/">http://www.w3.org/TR/REC-html40/</a> A typical <code>&lt;img&gt;</code> tag might look like:<p>
<pre class="fragment"><div>
&lt;img src="file.jpg" width="100" height="100" alt="description" /&gt;
</div></pre><p>
This tag has four attributes: <code>src</code>, <code>width</code>, <code>height</code>, and <code>alt</code>, with the values <code>file.jpg</code>, <code>100</code>, <code>100</code>, and <code>description</code>, respectively. Attributes in HTML tags are represented by the class <code><a class="el" href="classcgicc_1_1HTMLAttribute.html">cgicc::HTMLAttribute</a></code>, which essentially is a name/value pair. To build an <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code> containing <code><a class="el" href="classcgicc_1_1HTMLAttribute.html">cgicc::HTMLAttribute</a></code> objects, use the <code>set</code> method on <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code>. To generate the <code>&lt;img&gt;</code> tag given above:<p>
<pre class="fragment"><div>cout &lt;&lt; img().set(<span class="stringliteral">"src"</span>, <span class="stringliteral">"file.jpg"</span>)
             .set(<span class="stringliteral">"width"</span>, <span class="stringliteral">"100"</span>).set(<span class="stringliteral">"height"</span>, <span class="stringliteral">"100"</span>)
             .set(<span class="stringliteral">"alt"</span>, <span class="stringliteral">"description"</span>) &lt;&lt; endl;
</div></pre><p>
In a similar way, multiple <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code> objects may be embedded at the same level inside another <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code>. To build an <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code> containing multiple embedded <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code> objects, use the <code>add</code> method on <code><a class="el" href="classcgicc_1_1HTMLElement.html">cgicc::HTMLElement</a></code>:<p>
<pre class="fragment"><div>cout &lt;&lt; tr().add(td(<span class="stringliteral">"0"</span>)).add(td(<span class="stringliteral">"1"</span>)).add(td(<span class="stringliteral">"2"</span>)) &lt;&lt; endl;
</div></pre><p>
This produces as output <pre class="fragment"><div>
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
</div></pre><p>

</div>
<p>

<div class="header">Notes on Output</div>
<div class="subsection">
<p>
All of cgicc's output is written to a C++ standard output stream, usually <code>cout</code>. It is not necessary to use cgicc's HTML output classes; they are provided as a convenience. If you prefer, you may output the HTML code directly to <code>cout</code>.<p>

</div>
<p>

<div class="header">The Complete Example</div>
<div class="subsection">
<p>
The code below is a complete CGI program that synthesizes all the sample code given above.<p>
<pre class="fragment"><div><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>

<span class="preprocessor">#include "<a class="code" href="Cgicc_8h.html">cgicc/Cgicc.h</a>"</span>
<span class="preprocessor">#include "<a class="code" href="HTTPHTMLHeader_8h.html">cgicc/HTTPHTMLHeader.h</a>"</span>
<span class="preprocessor">#include "<a class="code" href="HTMLClasses_8h.html">cgicc/HTMLClasses.h</a>"</span>

<span class="keyword">using</span> <span class="keyword">namespace </span>std;
<span class="keyword">using</span> <span class="keyword">namespace </span>cgicc;

<span class="keywordtype">int</span> 
main(<span class="keywordtype">int</span> argc, 
     <span class="keywordtype">char</span> **argv)
{
   <span class="keywordflow">try</span> {
      <a class="code" href="classcgicc_1_1Cgicc.html">Cgicc</a> cgi;

      <span class="comment">// Send HTTP header</span>
      cout &lt;&lt; <a class="code" href="classcgicc_1_1HTTPHTMLHeader.html">HTTPHTMLHeader</a>() &lt;&lt; endl;

      <span class="comment">// Set up the HTML document</span>
      cout &lt;&lt; html() &lt;&lt; head(title(<span class="stringliteral">"Cgicc example"</span>)) &lt;&lt; endl;
      cout &lt;&lt; body() &lt;&lt; endl;

      <span class="comment">// Print out the submitted element</span>
      <a class="code" href="namespacecgicc.html#a0">form_iterator</a> name = cgi.<a class="code" href="classcgicc_1_1Cgicc.html#z5_3">getElement</a>(<span class="stringliteral">"name"</span>);
      <span class="keywordflow">if</span>(name != cgi.<a class="code" href="classcgicc_1_1Cgicc.html#z5_10">getElements</a>().end()) {
         cout &lt;&lt; <span class="stringliteral">"Your name: "</span> &lt;&lt; **name &lt;&lt; endl;
      }

      <span class="comment">// Close the HTML document</span>
      cout &lt;&lt; body() &lt;&lt; html();
   }
   <span class="keywordflow">catch</span>(exception&amp; e) {
      <span class="comment">// handle any errors - omitted for brevity</span>
   }
}
</div></pre><p>

</div>
<p>

<div class="nav">
Previous: <a class="el" href="lib_overview.html">Library Overview</a> | Current: <a class="el" href="cgicc_tutorial.html">A Tutorial Example</a> | Next: <a class="el" href="cgicc_demos.html">GNU cgicc Demos</a> 
</div>
<!-- $Id: footer.html,v 1.7 2004/06/12 01:58:25 sbooth Exp $ -->

<hr>

<address><small>
<a href="http://www.cgicc.org">GNU cgicc</a> - A C++ class library for
writing CGI applications<br />
Copyright &copy; 1996 - 2004 
<a href="mailto:sboothATgnuDOTorg">Stephen F. Booth</a><br />
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front Cover Texts, and with no Back-Cover
Texts.<br />
Documentation generated Sat Jun 19 00:36:23 2004 for cgicc by
<a HREF="http://www.doxygen.org/index.html">doxygen</a> 1.3.6
</small></address>

</body>

</html>

